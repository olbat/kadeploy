#!/usr/bin/ruby

#Main concept :
# Kascade is tool for scalable and reliable data broadcast.
# It deploy itself on each node with SSH,Taktuk or ClusterShell (help with deploy object)
# It establish an pipeline throught all nodes and send data inside this pipeline.
# In fault case it restablish the pipeline.
# Each process on nodes is called fountain. There are two kind of fountain.
# First fountain which send data only and another which send and recieve.
# To replay some messages in fault case, each fountain has cyclicBuffer which store temporary $config[:memsize] of messages.
# The mecanism to know if node is dead work in two steps. Timeout with select and ping the node.
# An simple protocol is used to facilitate the communication between nodes
# There is two output module Pipeoutput for pipe to another process and Fileoutput for write to file.

################################
## Rev 1:
##    -Little less verbose
##    -without -i take stay argument after parse to input
##    -put fountain.rb in temporary directory
##    -parse ssh command to get connexion parameter for kadeploy
##    -Add argument -m to set the master. (useful for integration next version )
##    -detection who_i_am is improved with ip search
## Rev 2:
##    -Use the reporting server to decide of end.
##    -Add yaml file and different status to communicate with kadeploy
##    -Add aggressive mod
##    -Retries options
## rev 3:
##    -Integration of Taktuk launcher
##    -Integration of cluster shell launcher (in progress - test ssh parameter)
##    -Improve the node sort
## rev 4:
##    -Fusion of both script
##    -Taktuk become by default
## rev 5:
##    -Add protocol
##    -ping server


require 'rubygems'
require 'optparse'
require 'thread'
require 'shellwords'
require 'timeout'
require 'logger'
require 'socket'
require 'tempfile'
require 'securerandom'
require 'yaml'
require 'open3'

# set old yameler
YAML::ENGINE.yamler = 'syck' if RUBY_VERSION >= '1.9'
Thread.abort_on_exception=true


VERSION='v1.5'
KEYWORDS = {
    :HELLO => "HELLO-Kascade-#{VERSION}", #Hand shake to be sure
    :GET => 'GET', #argument offset. Ask data from offset.
    :GET_PARTIAL => 'PGET', #arguments are from and to. It send data from byte to byte
    :DATA => 'DATA', #argument size of packet transfer the data
    :FORGET => 'FORGET', #argument min byte saved the data asked is too old
    :QUIT => 'QUIT', #abord the transfer
    :PASSED => 'PASSED', #inform all packet is passed useful if the node dead at end of report it don't shutdown
    :REPORTING => 'REPORT', #argument size of report. Transfer the node failed
    :END => 'END', #Explain the end of transfer
}

$log= Logger.new(STDERR)
$log.level=Logger::WARN
beginning_time = Time.now


###### Tools box

if RUBY_VERSION < '1.9' #backward compatiblity
  class File
    def self.absolute_path(path)
      Pathname.new(path).realpath
    end

    def size()
      File.size(self.path())
    end
  end
end

def fatal_error(message)
  $log.fatal message
  exit(1)
end

#Add function to transform string in integer if it is a number else it return the string
class String
  def numberize
    Integer(self) rescue self
  end
end

############ Network tools

#return local ip used to contact host.
def local_ip(destination)
  destination=destination.split(':')[0]
  orig, Socket.do_not_reverse_lookup = Socket.do_not_reverse_lookup, true
  UDPSocket.open do |s|
    s.connect destination, 1
    s.addr.last
  end
  ensure
    Socket.do_not_reverse_lookup = orig
end

#Read protocol command
def read_cmd(stream)
  line = stream.read(100)
  raise 'unexpected close' if !line || line=='' || line.size!=100
  line.strip!
  $log.debug "command #{line} is received"
  line.split(' ')
end

#Send protocol command
def send_cmd(stream, *cmd)
  $log.debug("send command #{cmd}")
  send_with_timeout(stream, (cmd*' ').ljust(100))
end

#Connect to host with port with timeout.
def connect_to(host, port)
  $log.debug "Try to connect #{host}:#{port}"
  Timeout::timeout($config[:timeout]) {
    TCPSocket.new(host, port)
  }
end

#Connect from line given in host list.
def connect(line)
  host=line.split(':')
  host[1]=$config[:port] if host[1]==nil
  con=connect_to(host[0], host[1])
  $log.info "connection successful to #{line}"
  con
end

#Try to connect to the next node n retries
def connect_try(line)
  retries=$config[:retries] # it can change with time
  0.upto(retries) do |i|
    begin
      return connect(line)
    rescue Errno::EHOSTUNREACH, Timeout::Error => ex
      #TODO : don't retry on timeout is a good behavior ?
      $log.debug ex
      raise ex
    rescue Exception => e
      $log.debug e
      raise e if retries==i
      $log.warn("Connection failed on #{line}, retrying (#{i+1}/#{retries}): #{e.to_s}")
      sleep 1
    end
  end
  raise "Retry limit is reached for #{line}. It's possible that is never tried !"
end

#Hand_shake to detect if kascade is connected on another kascade serveur
def hand_shake(client)
  return true unless $config[:handshake]
  send_cmd(client, KEYWORDS[:HELLO])
  version=read_cmd(client)[0]
  return true if version == KEYWORDS[:HELLO]
  $log.error("Bad protocol version: #{version}")
  false
end

#Send data in socket and wait it sent.
#When timeout is reached it test the node and throw exeption if it does not return
def send_with_timeout(stream, msg)
  while 0 < msg.size
    begin
      written = stream.write_nonblock(msg)
    rescue Errno::EWOULDBLOCK
      if IO.select(nil, [stream], nil, $config[:timeout])
        retry
      else
        addr=stream.peeraddr
        begin
          $log.info("timeout of #{addr[2]}:#{addr[1].to_i+$config[:dec_ping_port]} was reached check it")
          n_sock=connect_to(addr[2], addr[1].to_i+$config[:dec_ping_port])
          if n_sock.sysread(4) != 'pong'
            n_sock.close
            raise ('node dead')
          end
          n_sock.close
          $log.info("timeout of #{addr[2]}:#{addr[1]} ping retry")
          retry
        rescue Exception => e
          $log.debug(e)
          $log.info "ping to #{addr[2]}:#{addr[1]} failed !"
          raise ('node dead no ping')
        end
      end
    end
    msg = msg[written..-1]
  end
end

############ Node Management

#Get node hostname without port
def get_nodes_list
  $config[:nodeList].map { |node| node.split(':')[0] }
end


#Detect the position in the node list, the host which execute the current process.
def detect_who_i_am
  my_list = $config[:nodeList].map { |l| l.split(':')[0] }
  who=my_list.index(Socket.gethostname)
  unless who
    host=ENV['HOST']
    who = my_list.index(host) if host
  end
  unless who
    host=`hostname -s`.strip
    who = my_list.index(host) if host
  end
  unless who
    host=`hostname --fqdn`.strip
    who = my_list.index(host) if host
  end
  unless who
    who = my_list.index(local_ip($config[:master] || $config[:nodeList][0]))
  end
  who
end

#Get port from list
def get_port(line, add=0)
  host=line.split(':')
  host[1]=$config[:port] if host[1]==nil
  host[1]=host[1].to_i+add
  $log.debug "Try to listen on #{host[1]}"
  host[1]
end


#Open tcp socket and listen
def open_tcp_server(line = $config[:nodeList][$config[:who_i_am]])
  TCPServer.new(get_port(line))
end


#Deploy is abstract class to deploy this script on each nodes.
class Deploy

  #begins the deployment
  def start
    @thread=nil
    prefab
    deploy
  end

  #Simplify the thread creation with error logger
  def thread_catch_errors(*arg)
    @thread=Thread.new do
      begin
        yield arg
      rescue Exception => e
        $log.error e
      end
    end
  end

  def join
    @thread.join if @thread
  end

  #initialize some common variables
  def prefab
    @secure_random = SecureRandom.hex
    @fountain_path = '/tmp/kascade' + @secure_random + 'fountain.rb'
    @nodes_path = '/tmp/kascade' + @secure_random + 'node_file'

    @nodes_ports = Shellwords.escape($config[:nodeList]*"\n")

    #Prepare commands : Behaviour intermediate node have retries 1 and 2 or only 2 ?
    @common_options="-D none -M -b #{$config[:buffer_size]} -n '#{@nodes_path}' -r #{$config[:retries]} -R #{$config[:retries2][0]},#{$config[:retries2][1]} -v #{$log.level} -p #{$config[:port]} -m #{$config[:master]} -t #{$config[:timeout]} -W nil"
    @command_fountain="ruby #{@fountain_path} #{@common_options} #{$config[:output].arg}"
  end

  #read the script itself
  def get_fountain_shell
    Shellwords.escape(File.read(__FILE__))
  end

end

#deploy with ruby-netssh
class Ssh < Deploy
  attr_accessor :params
  def initialize()
    @params="No parameter for SSH"
  end

  def deploy
    $log.info 'Using ssh'
    require 'net/ssh'
    require 'net/ssh/multi'
    ssh_options={:timeout=>1}
    if $config[:ssh_command]!=nil
      # FIXME that code is super-ugly. instead we should provide several options for SSH things
      #       we want to support changing. But, well, there's .ssh/config, too...
      # FIXME we don't support running kascade with oarsh
      flip=true
      #Split the ssh command string to obtain an array of argument. This split is double quote compliant
      ssh_args=$config[:ssh_command].split(/"/).collect { |t| flip=!flip; flip ? t : t.split(' ') }.flatten
      ssh_options_str={}
      OptionParser.new do |opts|
        opts.on('-o', '--option OPTION', 'puts option in ssh') do |v|
          opts=v.split('=')
          ssh_options_str[opts[0].downcase]=opts[1].numberize
        end
        opts.on('-p', '--port PORT', 'set port') do |v|
          ssh_options[:port]=v
        end
        opts.on('-l', '--login LOGIN', 'puts option in ssh') do |v|
          ssh_options[:user]=v
        end
        opts.on('-i', '--identification FILE', 'identification file') do |v|
          ssh_options[:keys]=v
        end
        opts.on('-q', '--quiet', 'Not used') {}
      end.parse(ssh_args)
      unless ssh_options_str.empty?
        tr=Net::SSH::Config.translate(ssh_options_str)
        ssh_options.merge!(tr)
      end
      $log.info "options for ssh #{ssh_options}"
    end


    # ALL FOUNTAINS
    thread_catch_errors do
      Net::SSH::Multi.start(:on_error => :ignore) do |session|
        get_nodes_list.each { |node| session.use(node, ssh_options) }
        time = Time.now
        cmd = "echo #{get_fountain_shell} > #{@fountain_path} && echo #{@nodes_ports} > #{@nodes_path}"
        session.exec(cmd)
        session.loop
        time = Time.now - time
        $log.info "script forwarded in #{time}s"

        session.exec(@command_fountain)

        session.loop
      end
    end
  end
end

#deploy with taktuk in two step, first copy necessary files and second launch the process
class Taktuk < Deploy
  attr_accessor :params
  def initialize()
    @params="-t 3 -d -1 -w 100"
  end
  def deploy
    $log.info "Using Taktuk with parameters : '#{@params}'"

    if $config[:nodeFile]==nil || $config[:modified_node_list]
      node_file=Tempfile.new('node_with_port')
      $config[:nodeList].each { |n| node_file.puts(n) }
      node_file.close
      node_file=node_file.path
    else
      node_file=$config[:nodeFile]
    end
    file = Tempfile.new('node_without_port')
    get_nodes_list.each { |node| file.puts node.split(':')[0] }
    file.close
    if $config[:ssh_command]!=nil
      ssh_opt="-c \"#{$config[:ssh_command]}\""
    else
      ssh_opt=''
    end
    taktuk_common="taktuk  #{@params} #{ssh_opt}  #{$log.info? ? '' : '-o status=-'} -o output='\"$host\t- $message\"' -o error='\"$host\t- $message\"' -f #{file.path}"
    cmd="#{taktuk_common} broadcast put [ #{__FILE__} ] [ #{@fountain_path} ], broadcast put [ #{node_file} ] [ #{@nodes_path} ]"
    $log.debug 'launching: '+cmd
    system(cmd)
    cmd="#{taktuk_common} broadcast exec [ #{Shellwords.escape(@command_fountain)} ]"
    $log.debug 'launching: '+cmd
    thread_catch_errors do
      system(cmd)
    end
    $log.debug 'taktuk finished'
  end
end


#deploy with clush in two step, first copy necessary files and second launch the process
class Clush < Deploy
  attr_accessor :params
  def initialize()
    @params="-t 3"
  end
  def deploy
    $log.info "Using ClusterShell with parameters : #{@params}"
    node_set=`nodeset -f #{get_nodes_list*' '}`.strip
    if $config[:ssh_command]!=nil
      ssh_opt="--option='#{$config[:ssh_command]}'"
    else
      ssh_opt=''
    end
    clush = "clush #{@params} -w '#{node_set}' #{$log.info? ? '' : '-q'} #{ssh_opt}"
    cmd="#{clush} --copy #{__FILE__} --dest #{@fountain_path} "
    $log.debug 'launching: '+cmd
    system(cmd)
    in_cmd=Shellwords.escape("echo #{@nodes_ports} > #{@nodes_path} && #{@command_fountain}")
    cmd="#{clush} #{in_cmd}"
    $log.debug 'launching: '+cmd
    @pid=fork { exec(cmd) }
  end

  def join
    Process.wait(@pid)
  end
end
############ Data Management

#The cyclic buffer is a buffer used to store the stream
#It stay in memory the size of data and forget the oldest data when it saturates
#It can get part of stream from byte offset
class CyclicBuffer
  attr_reader :max_obj, :min_obj, :max_byte, :min_byte

  #Make buffer with size of string
  def initialize(size)
    @buffer=Array.new(size)
    @min_obj=-1
    @max_obj=-1
    @min_byte=-1
    @max_byte=-1
  end

  #Add string to the buffer.
  def push(new_obj)
    @max_obj+=1
    @max_byte+=new_obj.size
    i=@max_obj % @buffer.size
    if @buffer[i]!=nil
      @min_obj+=1
      @min_byte+=new_obj.size
    end
    @buffer[i]=new_obj
  end

  #Get the i th object
  def get(i)
    return nil if i>@max_obj || i<@min_obj
    @buffer[i % @buffer.size]
  end

  #get all object between i and j
  def get_from_to(i, j)
    raise 'Nothing in stack obj' if j>@max_obj || i<@min_obj
    while i<=j
      yield(@buffer[i % @buffer.size])
      i+=1
    end
  end

  #Get string from i bytes to j bytes
  def get_byte_from_to(i, j)
    raise 'Nothing in stack' if j>@max_byte || i<@min_byte
    index_begin, offset_begin = index(i)
    index_end, offset_end = index(j)
    if index_begin==index_end
      yield(@buffer[index_begin % @buffer.size][offset_begin..offset_end])
    else
      yield(@buffer[index_begin % @buffer.size][offset_begin..-1])
      get_from_to(index_begin+1, index_end-1) do |b|
        yield(b)
      end
      yield(@buffer[index_end % @buffer.size][0..offset_end])
    end
  end

  #Get address (index,offset) to acces on element i byte
  def index(i)
    byte=@max_byte-i+1
    j=@max_obj
    while byte>0 do
      byte-=@buffer[j % @buffer.size].size
      j-=1
    end
    j+=1
    [j, -byte]
  end

  #Get all byte from i
  def get_all_byte(i)
    raise 'Nothing in stack' if i>@max_byte || i<@min_byte
    j, offset=index(i)
    yield(@buffer[j % @buffer.size][offset..-1])
    if j<@max_obj
      get_all(j+1) do |b|
        yield(b)
      end
    end
  end

  #Get all object from index i
  def get_all(i)
    raise 'Nothing in stack' if i>@max_obj || i<@min_obj
    while i<=@max_obj
      yield(@buffer[i % @buffer.size])
      i+=1
    end
  end
end

#Class output is "abstract" class to output on each destination node.
#Now, there are only two class which implements this abstract class : FileOutput and PipeOutput.
#This kind of class is made in option parsing and initialized after with init function.
class Output
  attr_reader :queue

  #initialize with variable output. In abstract class i can define without parameter and extend it with parameter.
  def initialize(e)
    @stream=nil
    @threads=[]
  end

  #Reader is thread wich reads the queue and write in stream
  #The sized queue introduce little asynchronism to avoid lock between different system buffer.
  def reader
    @queue=SizedQueue.new($config[:buffer_in_memory])
    @threads << Thread.new do
      begin
        while (buff=@queue.pop)!=nil
          @stream.write(buff)
        end
        @stream.close
      rescue Exception => e
        $log.debug(e)
      end
    end
  end

  #this function is called when the transfer is interupted.
  def quit
    close
  end

  #This function is called at end of transfer.
  def close
    @queue.push(nil)
    @threads.each do |th|
      th.join
    end
    0
  end
end

#This class connect the output to standard input of a process launched by cmd.
class PipeOutput < Output
  attr_reader :stream, :queue

  #initialize with command to launch on each nodes.
  def initialize(cmd)
    super
    @cmd = cmd
  end

  #Thread to redirect a stream.
  #We use to read both ouput of popen3 and write to both standard output.
  def redirect(input, output)
    @threads<<Thread.new do
      until (line = input.gets).nil? do
        output.puts(line)
      end
    end
  end

  #Initialize the class: launch command and redirect all stream.
  def init
    @stream, @out_stream, @err_stream, @wait_thr=Open3.popen3(@cmd)
    @threads<<@wait_thr if @wait_thr #1.8 compatibility
    redirect(@out_stream, $stdout)
    redirect(@err_stream, $stderr)
    reader
  end

  #When a transfer is interupted, the child is interupted too with INT signal.
  def quit
    Process.kill('INT', @wait_thr.pid)
    super
  end

  #At end of transfer we wait the end on child and return the value.
  def close
    super
    @wait_thr ? @wait_thr.value.exitstatus : 0 #1.8 compatibility
  end

  #This function return the argument which this object is created.
  def arg
    "-O '#{@cmd}'"
  end
end

#This class connect the output to the file.
class FileOutput < Output
  attr_reader :stream, :queue

  #This object is created with filename of ouput. It accept a stream too.
  #By default it is on standard output.
  def initialize(file_name=$stdout)
    @file_name=file_name
    super
  end

  #Initialize the object with file opening if it not a stream.
  def init
    if @file_name.is_a?(String)
      @stream=File.open(@file_name, 'w')
    else
      @stream=@file_name
    end
    reader
  end

  #We close file when the transfer is interrupted.
  def quit
    close
    # TODO should we remove the file when interrupted during the transfer?
  end

  #This function return the argument which this object is created.
  def arg
    if @file_name.is_a?(String)
      "-o '#{@file_name}'"
    else
      '-o -'
    end
  end
end

#Report object manage the report.
class Report
  attr_reader :errors

  def initialize
    @errors={}
  end

  #Recieve the report from another node
  def receive_report(binary)
    @errors.merge!(YAML.load(binary))
  end

  #Add local error to the report
  def add_error(host, error)
    @errors[host]=error
  end

  #Send the report to the master (establish connexion, send and close)
  def send_report_master
    $log.info 'I am the last and I send report to master'
    client = connect($config[:master])
    send_reporting(client)
    client.close
  end

  #Send report packet in stream
  def send_reporting(stream)
    data=errors.to_yaml
    send_cmd(stream, KEYWORDS[:REPORTING], data.size)
    send_with_timeout(stream, data)
    $log.debug 'report sent'
  end


  #For display with the logger the repport bad or all nodes. It depends of verbosity setting
  def log_report(head, table, error_show=false)
    if $log.info? || error_show
      table.each do |node, error|
        str="#{head} #{node}#{error==nil ? '' : ' - '+error.to_s}"
        if error_show
          $log.error(str)
        else
          $log.info(str)
        end
      end
    end
  end

  #Write yaml file from object
  def write_yaml_file(file_name, object)
    begin
      file=File.open(file_name, 'w')
      file.puts(object.to_yaml)
      file.close
    rescue => e
      $log.error "error during open file #{file_name} #{e.to_s}"
    end
    $log.info("The report #{file_name} is written")
  end

  #Write yaml file for master use with options ok or ko file.
  def make_report_files
    if $config[:ok_file]!=nil
      ok_node=$config[:nodeList].select { |n| @errors[n]==nil }
      log_report('[node ok]', ok_node)
      write_yaml_file($config[:ok_file], ok_node)
    end
    $log.error("#{@errors.size} node(s) return(s) an error") if @errors.size!=0
    log_report('', @errors, true)
    if $config[:ko_file]!=nil
      write_yaml_file($config[:ko_file], @errors)
    end
  end
end

#Ping server is simple echo server lanched at start of service and anwser for test request when the previous node reach the timeout.
class PingServer
  def initialize(line = $config[:nodeList][$config[:who_i_am]])
    @threads=[]
    @running=true
    @socket=TCPServer.new(get_port(line, $config[:dec_ping_port]))
    @threads<<Thread.new {
      begin
        while @running
          @threads<<Thread.new(@socket.accept) { |client|
            begin
              client.syswrite('pong')
              $log.info "pong to #{client.peeraddr[2]} #{client.peeraddr[1]}"
            rescue Exception => e
              $log.debug(e)
            end
            client.close
          }
        end
      rescue Exception => e
        if @running
          $log.error(e)
        else
          $log.info('ping server is down')
        end
      end
    }
  end

  #shutdown of ping server and wait its end.
  def shutdown
    @running=false
    @socket.shutdown
    @threads.each do |th|
      th.join
    end
  end
end

class ReadException < Exception
  attr_reader :byte_readed

  def initialize(byte_readed)
    @byte_readed=byte_readed
  end
end

class ForgetException < Exception
  def initialize (ask, min)
    @ask=ask
    @min=min
  end

  def to_s
    "Forget ask: #{@ask} < min: #{@min}"
  end
end


#Abstract fountain is object which provides function common on master and other nodes
class AbstractFountain
  attr_reader :report

  def initialize
    @index=$config[:who_i_am]+1
    @passed=false
    @last_node=$config[:nodeList].size-1==$config[:who_i_am]
    @report=Report.new
    @chunk_size=$config[:buffer_size]*$config[:chunk_size]
    @shunting_down=false
  end

  #Wait the last step of protocol (passed)
  def wait_passed(output_stream)
    cmd=read_cmd(output_stream)
    if  cmd[0]!=KEYWORDS[:PASSED]
      raise "Bad Keyword #{cmd[0]}"
    end
  end

  #This function has two ways: the initial connexion and resume when the previous node in pippeline has problem
  #In case of next node has problem it reconnect to the next of next
  #way 1: Connection to the next node and read GET and execute block with GET parameter or passed end end the transfer
  #way 2: We just execute the block with last parameter.
  def connexion_next
    begin
      @last_node=$config[:nodeList].size==@index
      if @last_node #We are the last node
        yield nil, 0
      else
        begin
          if @output_stream # connexion to the next node is alive
            yield @output_stream, @byte_need_to_send
            return
          else #Connect to the next node
            @output_stream=connect_try($config[:nodeList][@index])
            @before_next_sender_header=0
            while true #In forget case the next node get missing part and get back with get.
              cmd=read_cmd(@output_stream)
              case cmd[0]
                when KEYWORDS[:GET]
                  @byte_need_to_send=cmd[1].to_i
                  begin
                    yield @output_stream, @byte_need_to_send
                    return
                  rescue ForgetException => e
                    $log.debug(e)
                  end
                when KEYWORDS[:PASSED] #End transfer is succefully
                  $log.info('file passed')
                  @passed=true
                  @output_stream.close
                  return
                else #Problem with prototol
                  $log.debug "#{cmd[0]} instead GET or PASSED"
                  raise "Bad Keyword '#{cmd[0]}'"
              end
            end
          end
        rescue ReadException => ex_read
          $log.debug(ex_read)
          raise ex_read
        rescue Exception => e
          host=$config[:nodeList][@index]
          $log.debug(e)
          $log.error("#{e.to_s} with #{host}")
          @report.add_error(host, e)
          @index+=1
          @retries=$config[:retries]
          @output_stream=nil
        end
      end
    end while  !@passed && !@last_node
  end
end

#This fountain is launched by the master.
class FirstFountain<AbstractFountain
  def initialize
    super
    # both cases are needed: on the master, '-'. on other nodes, nil.
    if $config[:input]=='-' or $config[:input]==nil # from standard input
      $stdin.binmode
      $log.info 'using standard input'
      @input=nil
      read_input_thread
      @cyclic_buffer=CyclicBuffer.new($config[:buffer_in_memory])
    else #From file
      $log.info "using  '#{$config[:input]}'"
      @input=File.open($config[:input])
      @cyclic_buffer=nil
    end
  end

  def start
    start_sender
    @master_server_thread.join
  end

  def start_sender
    connexion_next do |output_stream, byte_need_to_send|
      if output_stream #If we are not the last node
        send_data(output_stream, byte_need_to_send)
        report.send_reporting(output_stream)
        wait_passed(output_stream)
      end
    end
    shutdown_master_server if @last_node
  end

  #This thread loads a chunk in advance.
  def read_input_thread
    @queue=SizedQueue.new($config[:buffer_in_memory]) #times chunk_size ?
    @in_th=Thread.new do
      begin
        until $stdin.eof? do
          @queue.push($stdin.read(@chunk_size))
        end
        @queue.push(nil)
      rescue Exception => e
        $log.error e
      end
    end
  end

  #Add DATA header with chunk and return the size
  def send_chunk(output_stream, chunk)
    send_cmd(output_stream, KEYWORDS[:DATA], chunk.size)
    send_with_timeout(output_stream, chunk)
    chunk.size
  end

  #Send many chunk to the next node.
  def send_data(output_stream, byte_from)
    if $config[:input].nil? or $config[:input] == '-' # input stream
      if @cyclic_buffer.min_byte>byte_from
        send_cmd(KEYWORDS[:FORGET], min)
      else
        if @cyclic_buffer.max_byte>byte_from # looking for in memory
          @cyclic_buffer.get_all_byte(byte_from) do |buff|
            send_chunk(output_stream, buff)
          end
        end
        while !(chunk=@queue.pop).nil? && !$config[:QUIT] #read
          @cyclic_buffer.push(chunk)
          send_chunk(output_stream, chunk)
        end
      end
    else #File input
      input=@input
      size=input.size-byte_from
      buffer_size=$config[:buffer_size]
      chunk_size_b=$config[:chunk_size]*buffer_size
      offset=(byte_from % chunk_size_b)
      @input.seek(byte_from, IO::SEEK_SET)
      while size > 0 && !$config[:QUIT] #while all is not send and ctrl+c not pressed
        data_size=[(chunk_size_b)-offset, size].min
        offset=0
        send_cmd(output_stream, KEYWORDS[:DATA], data_size)
        size-=data_size
        while data_size > 0
          send_with_timeout(output_stream, input.read(buffer_size))
          data_size -=buffer_size
        end
      end
    end
    if $config[:QUIT] #If ctrl+c is pressed send quit command
      puts (' quit sent ...')
      send_cmd(output_stream, KEYWORDS[:QUIT])
    else #else send end of transfer.
      send_cmd(output_stream, KEYWORDS[:END])
    end
  end

  #This function sends data when a node ask part to the master.
  def send_data_master(output_stream, byte_from, byte_to)
    if $config[:input] != nil and $config[:input] != '-' #If read from file
      input=File.open($config[:input])
      input.seek(byte_from, IO::SEEK_SET)
      data_size=[byte_to-byte_from, input.size-byte_from].min
      buffer_size=$config[:buffer_size]
      send_cmd(output_stream, KEYWORDS[:DATA], data_size)
      while data_size>0
        p=input.read(buffer_size)
        send_with_timeout(output_stream, p)
        data_size-=p.size
      end
      input.close
    else #If it is a standard input
      if byte_from<@cyclic_buffer.min_byte
        send_cmd(output_stream, KEYWORDS[:FORGET], @cyclic_buffer.min_byte)
      else
        data_size=[byte_to-byte_from, @cyclic_buffer.max_byte-byte_from].min
        send_cmd(output_stream, KEYWORDS[:DATA], data_size)
        @cyclic_buffer.get_byte_from_to(byte_from, byte_from+data_size) do |buff|
          send_with_timeout(output_stream, buff)
        end
      end
    end
  end

  #Launch the master server.
  #Can change the $config[:master] value !
  def master_server
    counter = -1
    @master_server = nil

    #Adjust port in case of another kascade running on same node.
    begin
      counter += 1
      begin
        port = get_port($config[:master],counter)
        @master_server=TCPServer.new('0.0.0.0', port)
      rescue Errno::EADDRINUSE => ex
        raise ex if !$config[:adjust_port]
      end
    end while @master_server==nil
    if counter > 0
      $log.warn("Adjust master port to #{port}")
      $config[:master] = $config[:master].split(':')[0]+':'+port.to_s
      $config[:port] = port
    end
    @master_server_thread=Thread.new do
      begin
        until @shunting_down
          Thread.start(@master_server.accept) do |client|
            begin
              $log.info("#{client.peeraddr[2]} is connected on master")
              cmd=read_cmd(client)
              case cmd[0]
                when KEYWORDS[:GET_PARTIAL]
                  send_data_master(client, cmd[1].to_i, cmd[2].to_i)
                  send_cmd(client, KEYWORDS[:END])
                when KEYWORDS[:REPORTING]
                  report.receive_report(client.read(cmd[1].to_i))
                  shutdown_master_server
                else
                  $log.error("Reader has relieve unknown command #{cmd[0]}")
              end
            rescue Exception => ex
              $log.error(ex)
            end
            client.close
          end
        end
      rescue Exception => ex
        $log.error ex unless @shunting_down
        $log.info 'master server was shut down'
      end
    end
  end

  #Make report file and stop the master server
  def shutdown_master_server
    report.make_report_files
    @shunting_down=true
    @master_server.shutdown
  end

  def stop

  end
end

#This funtain is launched on another nodes than master.
class Fountain < AbstractFountain
  def initialize
    super
    @server=open_tcp_server
    $config[:output].init
  end

  def start
    start_receiver
  end

  #This function wait connexion and kill the reciever connexion if another node want to connects.
  #This usefull when a node crashed, the previous connect to the next but the next still wait the information from the dead node.
  def accept_pending
    @accept_thread=Thread.new {
      begin
        new_con=@server.accept
        @input_stream.shutdown if @input_stream rescue Exception
        @input_stream=new_con
      rescue Exception => ex
        $log.debug(ex) unless @shunting_down
      end
    }
  end

  #Accept all new connexion
  def accept
    accept_pending unless @accept_thread #initialisation
    @accept_thread.join
    accept_pending
    @input_stream
  end

  #When a part of data is definitivly lost the node abord the tranfert send QUIT to another.
  # TODO : send another word to kill the end of chain without send report to the master and inform the previous.
  def loose
    @report.add_error($config[:nodeList][$config[:who_i_am]], 'Forget Part')
    connexion_next do |output_stream,_|
      if output_stream
        send_cmd(output_stream, KEYWORDS[:QUIT])
        @report.send_reporting(output_stream)
        wait_passed(output_stream)
      end
    end
  end

  #This function receive the data from previous node
  def start_receiver
    cyclic_buffer=CyclicBuffer.new($config[:buffer_in_memory])
    input_stream=accept
    send_cmd(input_stream, KEYWORDS[:GET], cyclic_buffer.max_byte+1)
    begin
      begin
        cmd=read_cmd(input_stream)
        case cmd[0]
          when KEYWORDS[:DATA] #
            chunk_transmission(input_stream, cyclic_buffer, cmd[1].to_i)
          when KEYWORDS[:FORGET] # try to contact the master, WISH : Don't forget to check if previous node is the master. In this case you lose.
            begin
              master=connect $config[:master]
              send_cmd(master, KEYWORDS[:GET_PARTIAL], cyclic_buffer.max_byte+1, cmd[1].to_i)
              answer=read_cmd(master)
              case answer[0]
                when KEYWORDS[:FORGET] #You loose
                  loose
                  # Add to report
                  master.close
                  @game_over=true
                  break
                when KEYWORDS[:DATA] #recover part
                  begin
                    chunk_transmission(master, cyclic_buffer, answer[1].to_i)
                    answer=read_cmd(master)
                  end while answer[0]==KEYWORDS[:DATA]
                  send_cmd(input_stream, KEYWORDS[:GET], cyclic_buffer.max_byte+1)
                else
                  $log.error("Master send unknown command #{answer[0]}")
              end
            rescue Exception => e
              $log.error('Loose part')
              $log.debug(e)
              loose
            end
          when KEYWORDS[:QUIT] #End when previous send quit
            $log.info('quitting...')
            @report.add_error($config[:nodeList][$config[:who_i_am]], 'QUIT')
            $config[:QUIT]=1
            connexion_next do |output_stream,_|
              send_cmd(output_stream, KEYWORDS[:QUIT]) if output_stream
            end
            $config[:retries]=1
          #$config[:output].quit if $config[:output]
          when KEYWORDS[:END] #End of transfer
            $log.info('Ending ...')
            connexion_next do |output_stream,_|
              send_cmd(output_stream, KEYWORDS[:END]) if output_stream
            end
            ret=$config[:output].close
            @report.add_error($config[:nodeList][$config[:who_i_am]], "children process return non zero value: '#{ret}'") if ret!=0
          when KEYWORDS[:REPORTING] #report is arrived merge and resend.
            report.receive_report(input_stream.read cmd[1].to_i)
            connexion_next do |output_stream,_|
              if output_stream
                @report.send_reporting(output_stream)
                wait_passed(output_stream)
              else
                @report.send_report_master
              end
            end
            $log.info "Report #{@report.errors.size} element(s)"
            send_cmd(input_stream, KEYWORDS[:PASSED])
            $log.debug('Passed Send')
            break
          else #unknown command
            $log.error("Reader has relieve unknown command #{cmd[0]}")
            break
        end
      rescue Exception => ex #on error with previous wait a client.
        $log.error("Waiting another client - #{ex.to_s}")
        $log.debug(ex)
        input_stream.close rescue Exception {}
        input_stream=accept
        $log.error("#{input_stream.peeraddr[2]} take over")
        send_cmd(input_stream, KEYWORDS[:GET], cyclic_buffer.max_byte+1)
      end
    end while true
  end

  #Transmit the chunk by a small packets.
  def chunk_transmission(input_stream, cyclic_buffer, size)
    byte_remaining=size
    buffer_size=$config[:buffer_size]
    file=$config[:output].queue
    connexion_next do |output_stream, from_byte|
      if from_byte < cyclic_buffer.min_byte && output_stream
        send_cmd(output_stream, KEYWORDS[:FORGET], cyclic_buffer.min_byte)
        raise ForgetException.new(from_byte, cyclic_buffer.min_byte)
      end
      while output_stream && cyclic_buffer.max_byte > @byte_need_to_send #while asked part is already recieved
        send_size=[cyclic_buffer.max_byte-@byte_need_to_send+1, @chunk_size-@byte_need_to_send % @chunk_size].min
        to_size=@byte_need_to_send+send_size-1
        if @before_next_sender_header==0
          send_cmd(output_stream, KEYWORDS[:DATA], send_size)
          @before_next_sender_header=send_size
        end
        cyclic_buffer.get_byte_from_to(@byte_need_to_send, to_size) do |buff|
          send_with_timeout(output_stream, buff)
        end
        @before_next_sender_header-=send_size
        @byte_need_to_send+=send_size
      end
      if @before_next_sender_header==0 && output_stream
        send_cmd(output_stream, KEYWORDS[:DATA], byte_remaining)
        @before_next_sender_header=byte_remaining
      end
      while byte_remaining > 0 #Just in time mode
        read_needed=[buffer_size, byte_remaining].min
        buffer = input_stream.read(read_needed) rescue buffer=nil

        if buffer && buffer.size==read_needed
          byte_remaining-=buffer.size
          begin
            if output_stream
              send_with_timeout(output_stream, buffer)
              @before_next_sender_header-=buffer.size
            end
          rescue Exception => e #Write failure, ask new forwarder
            file.push(buffer)
            cyclic_buffer.push(buffer)
            raise e
          end
          file.push(buffer)
          cyclic_buffer.push(buffer)
        else #read failure wait new forwarder.
          if output_stream
            @byte_need_to_send+=size
          end
          raise ReadException.new(size-byte_remaining)
        end
      end
      if output_stream
        @byte_need_to_send+=size
      end

    end
  end
  #end of reciever and wait the effective end.
  def stop
    @shunting_down=true
    @server.shutdown
    @accept_thread.join
  end
end

# CONFIGURATION -----------------------
$config = {
    :adjust_port => true,
    :buffer_in_memory => 1600,
    :buffer_size => 1024*64, #1460*64
    :check_master => true,
    :chunk_size => 160,
    :dec_ping_port => 1000,
    :deploy => Ssh.new,
    :input => nil,
    :ko_file => nil,
    :master => nil,
    :modified_node_list => false,
    :mr_proper => false,
    :ok_file => nil,
    :output => nil,
    :port => 29015,
    :retries => 10,
    :retries2 => [10, 0],
    :ssh_command => nil,
    :timeout => 3,
    :use_ip => false,
    :wait_deploy => false,
    :who_i_am => -1,
}


OptionParser.new do |opts|
  opts.banner = "Usage: ruby #{__FILE__} [options]"
  opts.separator ''
  opts.separator 'Example usage:'
  opts.separator ' * Simple file broadcast to three hosts:'
  opts.separator '   kascade -N n2,n3,n4 -i myfile.tgz -o /home/login/myfile.tgz'
  opts.separator ' * Copy a tar archive and decompress on-the-fly:'
  opts.separator '   kascade -N n2,n3,n4 -i myfile.tgz -O \'tar -xzC /opt/\''
  opts.separator ' * Cloning a disk partition using dd, streaming Kascade\'s standard input:'
  opts.separator '   dd if=/dev/sda2 | gzip | kascade -i - -N n2,n3,n4 -O \'gunzip | dd of=/dev/sda2\''
  opts.separator ''
  opts.separator 'Main options:'
  opts.on('-i', '--input FILE', 'input file (- for stdin)') do |v|
    $config[:input] = v
    fatal_error "file #{v} does not exist" unless File.exist?(v) or v == '-'
  end
  opts.on('-k', '--ok FILE', 'list of successful nodes') { |v| $config[:ok_file] = v }
  opts.on('-K', '--ko FILE', 'list of failed nodes') { |v| $config[:ko_file] = v }
  opts.on('-n', '--node-file FILE', 'node file') do |v|
    $config[:nodeFile]=v
    begin
      $config[:nodeList] = File.readlines(v).map { |l| l.strip }
    rescue Exception => ex
      fatal_error "Error: could not open #{v} file: #{ex.to_s}"
    end
  end
  opts.on('-N', '--node n1[:p1],n2[:p2],...', Array, 'list of node') { |v| $config[:nodeList]=v }
  opts.on('-o', '--output [FILE]', 'output file') { |v| $config[:output] = FileOutput.new(v) }
  opts.on('-O', '--output-cmd [CMD]', 'output command') { |v| $config[:output] = PipeOutput.new(v) }
  opts.on('-v', '--verbose [fatal,error,warn,info,debug]', 'run verbosely') do |v|
    case v
      when 'warn'
        $log.level=Logger::WARN
      when 'debug'
        $log.level=Logger::DEBUG
      when 'info'
        $log.level=Logger::INFO
      when 'error'
        $log.level=Logger::ERROR
      when 'fatal'
        $log.level=Logger::FATAL
      when (Logger::DEBUG.to_s)..(Logger::FATAL.to_s)
        $log.level=v.to_i
      when nil
        $log.level=Logger::INFO
      else
        $log.level=Logger::INFO
        $log.info("Invalid log level '#{v}'. Using 'info'.")
    end
  end
  opts.on('-s', '--[no-]sort', 'sort and unify the nodes list') { |v| $config[:sort] = v }
  opts.on('-?', '--help', 'show this message') do
    puts opts
    exit
  end
  opts.separator ''
  opts.separator 'Performance & tuning options:'
  opts.on('-b', '--buffer-size SIZE', "read buffer size, in bytes (default: #{$config[:buffer_size]})") { |v| $config[:buffer_size] = v.to_i }
  opts.on('-c', '--disable-check-master', 'disable check master in node list') { |v| $config[:check_master] = false }
  opts.on('-C', '--chunk-size SIZE', "size of chunks (amount of data between headers). unit: buffer size (default: #{$config[:chunk_size]})")
  opts.on('-D', '--deploy [ssh,taktuk,clush]', [:ssh, :taktuk, :clush, :none], "Choose deployment method (default: #{$config[:deploy].class.to_s.downcase})") do |v|
    case v
      when :ssh
        $config[:deploy]=Ssh.new
      when :clush
        $config[:deploy]=Clush.new
      when :taktuk
        $config[:deploy]=Taktuk.new
      when :none
        $config[:deploy]=nil
      else
        raise "deploy type #{v} does not available"
    end
  end
  opts.on('-H', '--[no-]disable-handshake', 'disable the handshake') { |v| $config[:handshake]=!v }
  opts.on('-I', '--[no-]use-ip', 'Use ip instead hostname when -m is not set') { |v| $config[:use_ip]=v }
  opts.on('-m', '--master HOST', 'Specify the master hostname') { |v| $config[:master] = v }
  opts.on('-M', '--[no-]mr-proper', 'delete the script and node list') { |v| $config[:mr_proper] = v }
  opts.on('-p', '--port PORT', 'default port') { |v| $config[:port] = v }
  opts.on('-P', '--deploy-parameter PARAMETERS', "Set parameter for deployer") { |v| $config[:deploy_params] = v}
  opts.on('-r', '--retry NUM', "Set number retry attempts, by default this value is #{$config[:retries]} and each retry is performed after 1s") { |v| $config[:retries] = v.to_i }
  opts.on('-R', '--retry2 TIME,retries', Array, "Set new retries number after time second default is #{$config[:retries2][0]},#{$config[:retries2][1]} ") { |v| $config[:retries2] = v }
  opts.on('-S', '--ssh-command SSH', 'custom ssh command (experimental)') { |v| $config[:ssh_command] = v }
  opts.on('-t', '--timeout NUM', "Timeout for connection and buffer send/receive (default: #{$config[:timeout]})") { |v| $config[:timeout] = v.to_i }
  opts.on('-u', '--number-of-buffer NB', "Number of max buffer stored (default: #{$config[:buffer_in_memory]})") { |v| $config[:buffer_in_memory]=v.to_i }
  opts.on('-w', '--[no-]wait-deploy', 'wait end of deployment algorithm') { |v| $config[:wait_deploy] = v }
  opts.on('-W', '--who-i-am NUM', 'master node\'s index in the node list') { |v| $config[:who_i_am] = Integer(v) rescue nil }
  opts.on('', '--[no-]adjust-port', "Take the successor port if the port is already bound (#{$config[:adjust_port] ? 'enabled' : 'disabled'} by default)") { |v| $config[:adjust_port] = v }
end.parse!

if $config[:nodeList].nil?
  fatal_error("No nodes list specified. See kascade -?")
end

fatal_error("Retries value must be > 0") unless $config[:retries] > 0

if $config[:output].nil?
  fatal_error("No output mode specified. Use '-o FILE' or '-O COMMAND'. See kascade -?")
end

#Set deploy parameters if all is defined
$config[:deploy].params = $config[:deploy_params] if $config[:deploy_params] and $config[:deploy]

#Sort node by name
if $config[:sort]
  $config[:modified_node_list]=true
  $config[:nodeList].uniq!
  $config[:nodeList].sort_by! { |h| h.split('.').reverse.collect { |v| v.scan(/\d+|\p{Alpha}+|\W+/).map! { |n| n.to_i(36) } }.flatten }
end

#detect the position in node list
if $config[:who_i_am]==-1 && $config[:check_master]
  index=detect_who_i_am
  if index #check if master is in list.
    $config[:nodeList].delete_at(index)
    $log.warn 'master node is in the nodes list, removing it'
    $config[:modified_node_list]=true
    #inform than list loaded in memory is newest than file.
    #The effect is the master rewrite another file before to copy on nodes.
  end
end

#if the detection of who I am is failed.
unless $config[:who_i_am]
  $config[:who_i_am]=detect_who_i_am
  fatal_error('I don\'t know who I am!') unless $config[:who_i_am]
end

#If the address of master is not provided in options
unless $config[:master]
  if $config[:who_i_am]==-1
    #if we are the master. We use local IP to contact the first node.
    #TODO : A problem can occurs when each node of chain has distinct address to connect to the master
    if $config[:use_ip]
      $config[:master]=local_ip($config[:nodeList][0])
    else
      $config[:master]=`hostname`.strip
    end
  else
    fatal_error('I don\t know who are the master !')
  end
end

#### --- MAIN
#Schedule the set of second retries value
if $config[:retries2][0].to_i > 0 && $config[:retries2][1].to_i >= 0
  Thread.new do
    sleep($config[:retries2][0].to_i)
    $config[:retries]=$config[:retries2][1].to_i
    $log.info("retries pass to #{$config[:retries]}")

  end
else
  $log.info('second timeout is not activated')
end


time_before_fountain = Time.now

#Set the fountain and interruption control, and ping server.
if $config[:who_i_am]==-1 # master
  if $config[:input].nil?
    fatal_error("No input specified. Use '-i -' for stdin")
  end
  $config[:filesize]=File.size($config[:input]) if $config[:input] != '-'

  $log.info 'I am the master'
  Signal.trap('INT') do
    case $config[:QUIT]
      when nil
        $stdout.write('ctrl+c caught')
        $stdout.flush
        $config[:retries]=1
        $config[:QUIT]=1
      when 3
        exit! 3
      else
        $config[:QUIT]+=1
    end
  end


  fountain=FirstFountain.new
  begin
    fountain.master_server()
  rescue Errno::EADDRINUSE
    fatal_error("Port #{$config[:master].split(':')[1] || $config[:port]} is already bound")
  end

  #Deploy the fountain to another nodes if it asked
  #(Please don't add fatal check after here)
  $config[:deploy].start if $config[:deploy]!=nil && $config[:who_i_am]==-1

else
  Signal.trap('INT') { exit! 1 }
  ping=PingServer.new
  $log.info "I am number #{$config[:who_i_am]}"
  fountain=Fountain.new
end

#launch the fountain
#this is a blocking call
fountain.start

#Stop the ping server
ping.shutdown if ping

$log.info 'fountain exited'
fountain.stop
time_before_fountain = Time.now - time_before_fountain
$config[:deploy].join if $config[:deploy] && $config[:wait_deploy]
total_time = Time.now - beginning_time
if $config[:who_i_am]==-1 && $log.info?
  $log.info "\tFILE\t\t:\t#{$config[:input]}"
  $log.info "\tSIZE\t\t:\t#{$config[:filesize]} bytes"
  $log.info "\tNODES\t\t:\t#{$config[:nodeList].size}"
  $log.info "\tNODES ERROR \t:\t#{fountain.report.errors.size}"
  $log.info "\tTRANSFER TIME\t:\t#{time_before_fountain} seconds"
  $log.info "\tTOTAL TIME\t:\t#{total_time} seconds"
end

#Delete temporary file at end on deployed node
if $config[:mr_proper]
  File.unlink($config[:nodeFile]) if $config[:nodeFile] rescue Exception
  File.unlink(__FILE__) rescue Exception
end

#return values
exit 0 if fountain.report.errors.size ==0
exit 2 if fountain.report.errors.size < $config[:nodeList].size
exit 1
